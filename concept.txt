Java
    객체지향 프로그래밍 언어
        상속, 캡슐화, 다형성
    OS에 독립적, OS에 따라서 전혀 프로그램을 바꾸지 않아도 실행 가능
        Java Virtual Machine과 통신, JVM이 자바 응용프로램으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달
        JVM은 OS에 종속적이라서 여러 운영체제에 설치할 수 있는 서로 다른 버전의 JVM 제공
    자동 메모리 관리
        가비지 컬렉터가 자동으로 메모리를 관리
    네트워크와 분산처리 지원
    풍부한 클래스 라이브러리(JAVA API)
    멀티쓰레드 지원
        여러 쓰레드에 대한 스케쥴링을 자바 인터프리터가 담당
    동적 로딩 지원
        실행 시에 모든 클래스가 로딩되지 않고, 필요한 시점에 클래스를 로딩하여 사용
        일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않음, 비교적 유연한 처리

JVM(Java Virtual Machine)
    일반 애플리케이션의 코드는 OS만 거치고 HW로 전달
    JAVA는 JVM을 한 번 더 거치기 때문에 속도가 느리다는 단점
        바이트 코드(컴파일 된 자바코드)를 하드웨어의 기계어로 바로 변환해주는 JIT(Just In Time) 컴파일러와 향상된 최적화 기술이 적용되어서 속도 빨라짐

    JDK : JVM + Java API + development tools
    A.java => (javac.exe[java compiler]) => A.class => (java.exe[java interpreter]) => execute

    모든 코드는 클래스 안에 존해애햐 하며, 서로 관련된 코드들을 그룹으로 나누어 별도의 클래스 구성
    클래스들이 모여서, Java Application
    모든 클래스가 main method를 가지고 있어야 하는 것은 아니지만, 하나의 Java App에는 main method를 포함한 클래스가 반드시 하나는 존재해야
    main method : Java App의 시작점
    작성된 Java App을 실행할 때는, java.exe 다음에 main method를 포함한 클래스의 이름을 적어줘야 한다.

Java Application의 실행 과정
    1. 프로그램의 실행에 필요한 클래스(*.class)를 로드
    2. 클래스 파일 검사
    3. 지정된 클래스에서 main method 호출

변수
    int, long
    float, double : 실수 기본형은 double, float : 7자리까지 오차 없음, double은 15자리까지 오차 없음
    char, String : 'c'(character), "String"

상수
    final int variable = 4 => (literal);
    일단 상수에 값이 저장된 이후에는 변경 불가, 선언 후 나중에 할당 가능
    리터럴 : 그 자체로 값을 의미하는 것

리터럴의 타입과 접미사
    리터럴에도 타입이 존재, 리터럴에 접미사를 붙여서 타입을 구분
    정수 기본형은 int, long타입을 쓰고 싶다면, L을 붙임(425L)
    실수 기본형은 double, float타입을 쓰고 싶다면, F를 붙임
    byte와 short는 접미사 없음
    8진수 : 접두사 0, 16진수 : 접두사 0x
    정수형 리터럴의 중간에 _를 넣을 수 있음 (1_000 == 1000)

문자 리터럴과 문자열 리터럴
    char 리터럴은 안에 반드시 하나의 문자 필요
    String 리터럴은 안에 공백 가능
    String은 객체
    문자열 + any type = 문자열

자바는 참조형에 대한 연산 불가, 실제 연산에 사용되는것은 모두 기본형 변수

printf => C랑 같음, formatted print
    %d : 10진
    %x : 16진수
    %f : 부동소수점
    %c : 문자
    %s : string

타입이 정해져 있으므로, 오버플로우에 주의하자
    최솟값에서 1빼면 최댓값이 되고, 최댓값에서 1을 더하면 최솟값이 된다

타입 변환
    숫자 -> 문자

연산자
    산술 연산자 : + - * / % << >>
    비교 연산자 : < > <= >= == !=
    논리 연산자 : && || ! & | ^ ~
    대입 연산자 : =
    형변환 연산자 : (type)
    삼항 연산자 : ?
    타입체크 : instanceof

    우선순위 : 산술 > 비교 > 논리 > 대입, 단항 > 이항 > 삼항

    자동 형변환
        float f = 1234;
            1234를 float형태로 바꾸어야, 자동으로 형변환됨
            기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환
            표현 범위가 좁은 타입에서 넓은 타입으로 형변환 하는 경우에는, 넓은 쪽으로 변환

        큰 타입에서 작은 타입으로의 형 변환은 값 손실 발생 가능(정수형 -> 실수형 포함)
        (byte -> short -> int -> long -> float -> double)
        
        float과 int의 연산에서, int가 float으로 바뀌고, float과 float의 연산으로 바뀜
    
    산술 변환
        1. 두 피연산자의 타입을 같게 일치 시킴(보다 큰 타입으로 일치)
        2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환
            int가 가장 자연스러운 타입
    
    항상 변수의 타입과 리터럴의 타입에 대해서 따로 생각하자!

    등가 비교 연산자 ==,!=
        기본형의 경우, 변수에 저장되어 있는 값이 같은지
        참조형의 경우, 객체의 주소값을 저장하므로 두 개의 피연산자의 주소가 같은지

    문자열의 비교
        equals(), ==사용 불가
    
    복합 대입 연산자
        i *= 10 + j;
        가장 마지막에 이루어짐, i = i * (10+j) 와 같은 의미


Switch
    1. 조건식을 먼저 계산한 다음, 그 결과와 일치하는 case문으로 이동
    2. 이후의 문장들 수행
    3. break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나감

    switch문의 조거신 결과는 정수 또는 문자열이어야 함
    case문의 값은 정수 상수, 문자열만 가능하며 중복되지 않아야 함

난수
    Math.random() : 0이상 1미만 double return

continue
    while문에서 continue는 조건식으로 이동
    for문에서 continue는 증감식으로 이동

배열(Array)
    같은 타입의 변수를 하나의 묶음으로 다루는 것
    배열을 다루는 데 필요한 참조변수일 뿐 저장하기 위한 공간이 아님

    변수 타입에 따른 기본값
        boolean : false
        char : \u0000
        byte,short,int : 0
        long : 0L
        float : 0.0f
        double 0.0d 또는 0.0
        참조형(객체) : null
    
String : char배열에 기능을 추가한 것
    메소드
        charAt() : 해당위치에 있는 문자 반환
        length()
        substring(from,to) : to 포함 안됨
        equals()
        toCharArray()

Arrays method
    Arrays.toString() : 문자열로 편하게 출력
    Arrays.equals() : 배열에 저장된 모든 요소(참조값이 아닌, 실제 들어있는값)를 비교
    Arrays.copyOf()/copyOfRange() : 배열 전체/일부를 복사
    Arrays.sort()
    
Object Oriented Programming(객체지향 프로그래밍)
    기존의 프로그래밍에 몇 가지 새로윤 규칙을 추가, 발전
    
    장점
        코드의 재사용성이 높음, 유지보수 용이
        코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경
        신뢰성이 높은 프로그래밍(제어자, 메소드 사용, 데이터 보호, 올바른값 유지, 코드의 중복 제거)

    클래스 : 객체를 정의해 놓은 것, 객체의 설게도
    객체(instance,object) : 실제로 존재하는 것

    당연히 직접 객체를 만들고 난 뒤 부터 사용 가능
    클래스를 정의하고 클래스를 통해 객체를 생성하는 이유는, 설계도를 통해서 제품을 만드는 이유와 같음
    
    객체의 구성요소
        속성과 기능(멤버)의 집합
        속성 : 변수, 기능 : 메소드

    인스턴스화 : 클래스로부터 객체를 만드는 과정
    객체는 모든 인스턴스를 대표하는 포괄적 의미, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 보다 강조
    
    하나의 소스파일에 하나의 클래스만을 정의하는것이 보통, 하나의 소스파일에 두 개 이상의 클래스를 정의하는것도 가능
    파일명은 public class의 이름과 일치해야 함

    변수 : 하나의 데이터를 저장할 수 있는 공간
    배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장
    구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장
    클래스 : 구조체와 함수의 결합

    객체지향 언어에서는 제어자를 이요해서 변수의 값을 직접 변경하지 못하게 하고, 메소드를 통해서 값을 변경하도록 작성 가능
    ex) 시,분,초 에서 시는 0~23의 값을 가져야 함, 지정된 값의 유효성을 점검할 수 있음

    ex) int hour1,hour2,hour3;
        int minute1,minute2,minute3;
        int second1,second2,second3;(X)

        Time t1 = new Time();
        Time t2 = new Time();
        Time t3 = new Time();(O)

    변수의 종류
        클래스 변수(static) : 클래스 영역, 클래스가 메모리에 올라갈 때 생성, 모든 인스턴스가 공통된 값(저장 공간)을 공유
        인스턴스 변수 : 클래스 영역, 인스턴스가 생성되었을 때 생성, 인스턴스마다 서로 다른 값(저장 공간)
        지역 변수 : 메서드, 생성자, 초기화 블럭 내부(클래스 영역 이외), 변수 선언문이 수행됐을 때 생성

    메소드의 리턴값은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다.


Call Stack
    메소드가 호출되면, 호출스택에 호출된 메소드를 위한 메모리가 할당, 이 공간에 지역변수/매개변수와 연산의 중간결과 저장
    메소드가 작업을 마치면 반환
    Call Stack의 맨 위에 있는 메소드가 현재 실행중인 메소드
    아래에 있는 메소드가 바로 위의 메소드를 호출한 메소드
    return type이 있는 메소드는 종료되면서 결과값을 자신을 호출한 메소드에게 반환
    대기상태에 있던 메소드는 넘겨받은 반환값으로 수행을 계속 진행

기본형 매개변수 : readonly
참조형 매개변수 : read and write, 인스턴스의 주소가 복사

static을 사용하는 경우
    static method
        클래스 메서드는 인스턴스 변수 사용 불가
        인스턴스와 관계가 없는 경우, 즉 인스턴스 변수/인스턴스 메서드를 사용하지 않는 경우 사용
    
    static member
        클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통(같은 값)으로 사용하는 것에 static
        static이 붙은 건 클래스가 메모리에 올라갈 때 이미 자동적으로 생성

같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조/호출 가능
단, 클래스(static) 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 함

오버로딩((method) Overloading)
    한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 갯수 또는 타입이 다르다면 같은 이름을 사용해서 정의 가능
    
    1. 메소드 이름이 같아야 함
    2. 매개변수의 갯수 또는 타입이 달라야 함(매개변수의 이름은 구별하지 않음)
    3. 반환 타입은 관계 없음(System.out.println 생각)
    
    매개변수의 순서만 다른 경우는 지양할 것
        long add(int a, long b)
        long add(long a, int b)
            add(3,3L)은 1번째, add(3L,3)은 2번째 호출 add(3,3)은 에러
            
생성자(constructor)
    인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드
    인스턴스 생성시에 실행되어야 하는 작업을 위해서도 사용
    생성자의 이름은 크래스의 이름과 같아야 하며, 리턴값이 없음

    연산자 new가 인스턴스를 생성, 생성자가 인스턴스를 생성하는 것이 아님(초기화 작업일 뿐)
    
    기본 생성자 : 자동 생성, 이미 생성된 생성자가 있다면 생성되지 않음
        Class(){}

    클래스를 생성할 때는 어떤 클래스를 생성할 것인지, 어떤 생성자를 사용할 것인지 결정해야 한다.

this
    생성자의 이름으로 클래스 이름대신 this를 사용
    한 생성자에서 다른 생성자를 호출할 때에는 반드시 첫 줄에서만 가능
    this.variable : 인스턴스 변수
    
    static은 this 사용 불가, 인스턴스가 생성되어 있을지 모름
    
    this : 인스턴스 자신을 가르키는 참조 변수, 인스턴스의 주소가 저장, 모든 인스턴스 메서드에 지역변수로 숨겨진채로 존재
    this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용
    
    this와 this()는 완전히 다름!

변수의 초기화   
    지역변수는 사용하기 전에 반드시 초기화
    멤버변수(클래스 변수와 인스턴스 변수), 배열의 초기화는 선택적(기본값이 들어감)
    boolean : false, 숫자 : 0, 참조형 : null

멤버변수(클래스 변수와 인스턴스 변수)의 초기화
    1. 클래스 변수 초기화 -> 인스턴스 변수 초기화
    2. 자동 초기화 -> 명시적 초기화 -> 초기화 블럭, 생성자

    명시적 초기화 : 선언과 동시에 초기화(int door=4;)
    초기화 블럭 : 클래스 초기화 블럭(static{}) / 인스턴스 초기화 블럭({})
    클래스 초기화 블럭은 한번만 실행되지만, 인스턴스 초기화 블럭은 인스턴스가 생성될 때마다 실행
    


