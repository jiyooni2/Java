Java
    객체지향 프로그래밍 언어
        상속, 캡슐화, 다형성
    OS에 독립적, OS에 따라서 전혀 프로그램을 바꾸지 않아도 실행 가능
        Java Virtual Machine과 통신, JVM이 자바 응용프로그램으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달
        JVM은 OS에 종속적이라서 여러 운영체제에 설치할 수 있는 서로 다른 버전의 JVM 제공
    자동 메모리 관리
        가비지 컬렉터가 자동으로 메모리를 관리
    네트워크와 분산처리 지원
    풍부한 클래스 라이브러리(JAVA API)
    멀티쓰레드 지원
        여러 쓰레드에 대한 스케쥴링을 자바 인터프리터가 담당
    동적 로딩 지원
        실행 시에 모든 클래스가 로딩되지 않고, 필요한 시점에 클래스를 로딩하여 사용
        일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않음, 비교적 유연한 처리

컴퓨터 구조에 따라 사용하는 기계어가 달라지며, 따라서 기계어에 대응되어 만들어지는 어셈블리어도 각각 다르게 된다.
    > 이에 따라 컴파일러, 인터프리터가 필요해짐

컴파일러
    완전한 프로그램은 컴파일러를 사용하여 자연스러운 영어와 유사한 구문으로 작성된 다음 언어가 전체 코드를 기계어로 컴파일하거나 번역합니다. 
    컴파일된 코드는 하드웨어에서 실행됩니다.

    컴파일(Compile)은 주어진 language로 작성된 컴퓨터 프로그램을 다른 언어의 동등한 프로그램으로 변환하는 프로세스입니다. 
    컴파일러는이 작업을 실행하는 소프트웨어입니다. 때로는이 작업을 "조립(assembling)"또는 "빌드(build)"라고도 합니다. 
    이 작업들은 보통 컴파일과 같은 것(예를 들면 바이너리 형식으로 패키지를 만드는 일) 이상의 작업을 수행합니다 .
    일반적으로 컴파일러는 C 또는 Java 와 같은 고급 언어를 CPU가 이해할 수 있는, 즉 어셈블리어와 같은 기계 언어로 변환합니다. 
    유사한 수준의 언어 사이에서 번역하는 일부 컴파일러를 트랜스파일러 또는 크로스 컴파일러 라고 합니다. 
    예를 들어 TypeScript에서 JavaScript로 컴파일합니다.

    전체 파일을 스캔하여 한꺼번에 번역한다.
    초기 스캔시간이 오래 걸리지만, 한번 실행 파일이 만들어지고 나면 빠르다.
    기계어 번역과정에서 더 많은 메모리를 사용한다.(소스 -> 기계어로 바꾸는 과정에서 오브젝트 코드 생성, 오브젝트 코드의 링킹이 필요)
    전체 코드를 스캔하는 과정에서 모든 오류를 한꺼번에 출력해주기 때문에 실행 전에 오류를 알 수 있다. -> Compile Error
    대표적인 언어로 C, C++, JAVA 등이 있다.


인터프리터
    인터프리터를 사용하면 모든 고급 코드 문장이 즉석에서 기계어로 해석됩니다
    작성된 문은 다음 문을 보기 전에 하드웨어에서 즉시 실행됩니다
    인터프리터는 고급 언어로 작성된 원시코드 명령어들을 한번에 한 줄씩 읽어들여서 실행하는 프로그램이다
    인터프리터는 고급 명령어들을 중간 형태로 번역한 다음, 그것을 실행한다. 

    프로그램 실행시 한 번에 한 문장씩 번역한다.
    한번에 한문장씩 번역후 실행 시키기 때문에 실행 시간이 느리다.
    컴파일러와 같은 오브젝트 코드 생성과정이 없기 때문에 메모리 효율이 좋다.
    프로그램을 실행시키고 나서 오류를 발견하면 바로 실행을 중지 시킨다. 실행 후에 오류를 알 수 있다. -> Runtime Error
    대표적인 언어로 Python, Ruby, Javascript 등이 있다.

Java 프로그램은 JVM(Java Virtual Machine)을 사용하여 위의 두 가지 방법을 결합한 최초의 언어였습니다
Java 코드 컴파일러를 Java Virtual Machine이라고 합니다. 모든 Java 파일은 먼저 바이트 코드로 컴파일됩니다
Java 바이트코드는 JVM에서만 실행할 수 있습니다. 그런 다음 JVM은 바이트코드를 해석하여 기본 하드웨어 플랫폼에서 실행합니다
따라서 애플리케이션이 Windows 시스템에서 실행 중인 경우 JVM은 이를 Windows용으로 해석합니다
그러나 Linux와 같은 오픈 소스 플랫폼에서 실행 중인 경우 JVM은 이를 Linux용으로 해석합니다. 
    > 모든 OS에서 해석되기 위해서 한 것 인듯


JVM(Java Virtual Machine)
    https://pienguin.tistory.com/entry/JAVA-%EC%9E%90%EB%B0%94-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EC%8B%A4%ED%96%89-%EA%B3%BC%EC%A0%95-%EB%B0%8F-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0 
    
    일반 애플리케이션의 코드는 OS만 거치고 HW로 전달
    JAVA는 JVM을 한 번 더 거치기 때문에 속도가 느리다는 단점
        바이트 코드(컴파일 된 자바코드)를 하드웨어의 기계어로 바로 변환해주는 JIT(Just In Time) 컴파일러와 향상된 최적화 기술이 적용되어서 속도 빨라짐

    JDK : JVM + Java API + development tools
    A.java => (javac.exe[java compiler]) => A.class => (java.exe[java interpreter]) => execute

    모든 코드는 클래스 안에 존재해야 하며, 서로 관련된 코드들을 그룹으로 나누어 별도의 클래스 구성
    클래스들이 모여서, Java Application
    모든 클래스가 main method를 가지고 있어야 하는 것은 아니지만, 하나의 Java App에는 main method를 포함한 클래스가 반드시 하나는 존재해야
    main method : Java App의 시작점
    작성된 Java App을 실행할 때는, java.exe 다음에 main method를 포함한 클래스의 이름을 적어줘야 한다.

    Java compiler
        Java Source파일을 JVM이 해석할 수 있는 Java Byte Code(. class)로 변경한다.
        일반적인 윈도우 프로그램의 경우, Compile 이후 Assembly 언어로 구성된 파일이 생성된다.

    Class Loader
        JVM내로 .class파일들을 Load 한다. 
        Loading 된 클래스들을 Runtime Data Area에 배치된다. 
        일반적인 윈도우 프로그램의 경우 Load 과정은 OS가 주도한다.

    Execution Engine
        Loading 된 클래스의 Byte code를 해석한다. 이 과정에서 ByteCode가 BinaryCode로 변경된다. 
        일반적인 윈도우 프로그램의 경우 Assembler가 Assembly언어로 쓰인 코드 파일을 BinaryCode로 변경한다.

    Garbage Collector : https://mangkyu.tistory.com/118
        메모리 누수를 방지하기 위해 가비지 컬렉터(Garbage Collector, GC)가 주기적으로 검사하여 메모리를 청소해준다.

        Minor GC vs Major GC

        JVM의 heap 영역은 처음 설계될 때 2가지의 전제 존재
            대부분의 객체는 금방 접근 불가능한 상태가 된다.
            오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

            >즉, 객체는 대부분 일회성이며, 메모리에 오랫동안 남아있는 경우는 드물다.
            그렇기 때문에 객체의 생존 기간에 따라 물리적인 Heap 영역을 나누게 되었고 Young, Old 총 2가지 영역으로 설계되었다.
        
        Young 영역(Young Generation)
            새롭게 생성된 객체가 할당(Allocation)되는 영역
            대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 많은 객체가 Young 영역에 생성되었다가 사라진다.
            Young 영역에 대한 가비지 컬렉션(Garbage Collection)을 Minor GC라고 부른다.

        Old 영역(Old Generation)
            Young영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
            Young 영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생한다.
            Old 영역에 대한 가비지 컬렉션(Garbage Collection)을 Major GC 또는 Full GC라고 부른다.
        
        Old 영역이 Young 영역보다 크게 할당되는 이유는 Young 영역의 수명이 짧은 객체들은 큰 공간을 필요로 하지 않으며 큰 객체들은 Young 영역이 아니라 바로 Old 영역에 할당되기 때문이다.
        예외적인 상황으로 Old 영역에 있는 객체가 Young 영역의 객체를 참조하는 경우도 존재할 것이다. 
        이러한 경우를 대비하여 Old 영역에는 512 bytes의 덩어리(Chunk)로 되어 있는 카드 테이블(Card Table)이 존재한다.

        Card Table
            카드 테이블에는 Old 영역에 있는 객체가 Young 영역의 객체를 참조할 때 마다 그에 대한 정보가 표시된다. 
            카드 테이블이 도입된 이유는
            > Young 영역에서 가비지 컬렉션(Minor GC)가 실행될 때 모든 Old 영역에 존재하는 객체를 검사하여 참조되지 않는 Young 영역의 객체를 식별하는 것이 비효율적이기 때문이다. 
            > 쓰는지 안쓰는지 검사하려면, Old 영역의 객체가 쓰는지도 검사를 해야 하니까
            그렇기 때문에 Young 영역에서 가비지 컬렉션이 진행될 때 카드 테이블만 조회하여 GC의 대상인지 식별할 수 있도록 하고 있다.

        동작 방식
            공통
            1. Stop The World -> 2. Mark and Sweep

            1. Stop the World
                JVM이 애플리케이션의 실행을 멈추는 작업이다. 
                GC가 실행될 때는 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업이 중단되고, GC가 완료되면 작업이 재개된다.
                GC의 성능 개선을 위해 튜닝을 한다고 하면 보통 stop-the-world의 시간을 줄이는 작업을 하는 것이다. 
                또한 JVM에서도 이러한 문제를 해결하기 위해 다양한 실행 옵션을 제공하고 있다.

            2. Mark and Sweep
                Mark: 사용되는 메모리와 사용되지 않는 메모리를 식별하는 작업
                Sweep: Mark 단계에서 사용되지 않음으로 식별된 메모리를 해제하는 작업
                Stop The World를 통해 모든 작업을 중단시키면, 
                GC는 스택의 모든 변수 또는 Reachable 객체를 스캔하면서 각각이 어떤 객체를 참고하고 있는지를 탐색하게 된다. 
                그리고 사용되고 있는 메모리를 식별하는데, 이러한 과정을 Mark라고 한다. 
                이후에 Mark가 되지 않은 객체들을 메모리에서 제거하는데, 이러한 과정을 Sweep라고 한다.


            Minor GC
                객체가 새롭게 생성되면 Young 영역 중에서도 Eden 영역에 할당(Allocation)이 된다. 
                그리고 Eden 영역이 꽉 차면 Minor GC가 발생하게 되는데, 사용되지 않는 메모리는 해제되고 Eden 영역에 존재하는 객체는 (사용중인) Survivor 영역으로 옮겨지게 된다. 

                순서
                    새로 생성된 객체가 Eden 영역에 할당된다.
                    객체가 계속 생성되어 Eden 영역이 꽉차게 되고 Minor GC가 실행된다.
                    Eden 영역에서 사용되지 않는 객체의 메모리가 해제된다.
                    Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동된다.
                    1~2번의 과정이 반복되다가 Survivor 영역이 가득 차게 되면 Survivor 영역의 살아남은 객체를 다른 Survivor 영역으로 이동시킨다.(1개의 Survivor 영역은 반드시 빈 상태가 된다.)
                    이러한 과정을 반복하여 계속해서 살아남은 객체는 Old 영역으로 이동(Promotion)된다.

                객체의 생존 횟수를 카운트하기 위해 Minor GC에서 객체가 살아남은 횟수를 의미하는 age를 Object Header에 기록한다. 
                그리고 Minor GC 때 Object Header에 기록된 age를 보고 Promotion 여부를 결정한다.
                또한 Survivor 영역 중 1개는 반드시 사용이 되어야 한다. 
                만약 두 Survivor 영역에 모두 데이터가 존재하거나, 모두 사용량이 0이라면 현재 시스템이 정상적인 상황이 아님을 파악할 수 있다.
                


    Runtime Data Area(JVM memory)
        JVM이 프로세스로써 수행되기 위해 OS로부터 할당받는 메모리 영역이다. 저장 목적에 따라 다음과 같이 5개로 나눌 수 있다.
        
        Method Area
            모든 Thread에게 공유된다. 
            new 명령어로 생성된 인스턴스와 객체가 저장되는 구역, 공간이 부족해지면 Garbage Collection이 실행된다.

        Stack Area
            각 스레드마다 하나씩 생성된다. 
            Method안에서 사용되는 값들(매개변수, 지역변수, 리턴 값 등)이 저장되는 구역
            메서드가 호출될 때 LIFO로 하나씩 생성되고, 메서드 실행이 완료되면 LIFO로 하나씩 지워진다.

        PC register
            각 스레드마다 하나씩 생성된다. 
            CPU의 Register와 역할이 비슷하다. 현재 수행 중인 JVM명령의 주소 값이 저장된다.

        Native Method Stack
            각 스레드마다 하나씩 생성된다. 
            다른 언어(C/C++ 등)의 메서드 호출을 위해 할당되는 구역 언어에 맞게 Stack이 형성되는 구역이다. 
            JNI(Java Native Interface)라는 표준 규약을 제공한다.


Java Application의 실행 과정
    1. 프로그램의 실행에 필요한 클래스(*.class)를 로드 (java compiler, class loader)
    2. 클래스 파일 검사 
    3. 지정된 클래스에서 main method 호출

변수
    int, long (4,8)
    float(4), double(8) : 실수 기본형은 double, float : 7자리까지 오차 없음, double은 15자리까지 오차 없음
    char(1), String : 'c'(character), "String"

상수
    final int variable = 4 => (literal);
    일단 상수에 값이 저장된 이후에는 변경 불가, 선언 후 나중에 할당 가능
    리터럴 : 그 자체로 값을 의미하는 것

리터럴의 타입과 접미사
    리터럴에도 타입이 존재, 리터럴에 접미사를 붙여서 타입을 구분
    정수 기본형은 int, long타입을 쓰고 싶다면, L을 붙임(425L)
    실수 기본형은 double, float타입을 쓰고 싶다면, F를 붙임
    byte와 short는 접미사 없음
    8진수 : 접두사 0, 16진수 : 접두사 0x
    

문자 리터럴과 문자열 리터럴
    char 리터럴은 안에 반드시 하나의 문자 필요
    String 리터럴은 안에 공백 가능
    String은 객체
    문자열 + any type = 문자열

자바는 C언어와 같이 참조형에 대한 연산 불가, 실제 연산에 사용되는것은 모두 기본형 변수

JAVA : strictly pass-by-value
    Object 또한 value가 주어지는 것, not pass-by-reference

    https://mangkyu.tistory.com/105
    https://mangkyu.tistory.com/106
    https://mangkyu.tistory.com/107

    객체가 생성되면, Heap 영역에 실제 값이 할당되며, 이를 할당한 변수는 Stack 영역에 존재, 실제 주소가 저장됨
    
    int[] var={1,2,3}
    heap에 {1,2,3} 저장되고, var는 stack에 저장, var에는 주소가 저장됨
    {1,2,3}은 각각 주소가 저장되며, '1'도 heap에 저장됨 {1,2,3}에서 1에 '1'의 주소가 저장됨 

    Pass By Value로 저장되므로, value를 복사해서 새로운 변수를 스택에 생성
    value => 우리가 아는 값을 의미하는게 아닌, stack에 저장된 값


printf => C랑 같음, formatted print
    %d : 10진
    %x : 16진수
    %f : 부동소수점
    %c : 문자
    %s : string

타입이 정해져 있으므로, 오버플로우에 주의하자
    최솟값에서 1빼면 최댓값이 되고, 최댓값에서 1을 더하면 최솟값이 된다

타입 변환
    숫자 -> 문자

연산자
    산술 연산자 : + - * / % << >>
    비교 연산자 : < > <= >= == !=
    논리 연산자 : && || ! & | ^ ~
    대입 연산자 : =
    형변환 연산자 : (type)
    삼항 연산자 : ?
    타입체크 : instanceof

    우선순위 : 산술 > 비교 > 논리 > 대입, 단항 > 이항 > 삼항

    자동 형변환
        float f = 1234;
            1234를 float형태로 바꾸어야, 자동으로 형변환됨
            기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환
            표현 범위가 좁은 타입에서 넓은 타입으로 형변환 하는 경우에는, 넓은 쪽으로 변환

        큰 타입에서 작은 타입으로의 형 변환은 값 손실 발생 가능(정수형 -> 실수형 포함)
        (byte -> short -> int -> long -> float -> double)
        
        float과 int의 연산에서, int가 float으로 바뀌고, float과 float의 연산으로 바뀜
    
    산술 변환
        1. 두 피연산자의 타입을 같게 일치 시킴(보다 큰 타입으로 일치)
        2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환
            int가 가장 자연스러운 타입
    
    항상 변수의 타입과 리터럴의 타입에 대해서 따로 생각하자!

    등가 비교 연산자 ==,!=
        기본형의 경우, 변수에 저장되어 있는 값이 같은지
        참조형의 경우, 객체의 주소값을 저장하므로 두 개의 피연산자의 주소가 같은지

    문자열의 비교
        equals(), ==사용 불가
    
    복합 대입 연산자
        i *= 10 + j;
        가장 마지막에 이루어짐, i = i * (10+j) 와 같은 의미


Switch
    1. 조건식을 먼저 계산한 다음, 그 결과와 일치하는 case문으로 이동
    2. 이후의 문장들 수행
    3. break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나감

    switch문의 조건의 결과는 정수 또는 문자열이어야 함
    case문의 값은 정수 상수, 문자열만 가능하며 중복되지 않아야 함

난수
    Math.random() : 0이상 1미만 double return

continue
    while문에서 continue는 조건식으로 이동
    for문에서 continue는 증감식으로 이동
    > 외우지 말고, 당연한 흐름으로 생각하자
    > 이어서(continue) 다음 연산을 진행한다 라는 느낌으로 생각

배열(Array)
    같은 타입의 변수를 하나의 묶음으로 다루는 것
    배열을 다루는 데 필요한 참조변수일 뿐 저장하기 위한 공간이 아님

    변수 타입에 따른 기본값
        boolean : false
        char : \u0000
        byte,short,int : 0
        long : 0L
        float : 0.0f
        double 0.0d 또는 0.0
        참조형(객체) : null
    
String : char배열에 기능을 추가한 것
    메소드
        charAt() : 해당위치에 있는 문자 반환
        length()
        substring(from,to) : to 포함 안됨 = slice
        equals()
        toCharArray()

Arrays method
    Arrays.toString() : 문자열로 편하게 출력
    Arrays.equals() : 배열에 저장된 모든 요소(참조값이 아닌, 실제 들어있는값)를 비교
    Arrays.copyOf()/copyOfRange() : 배열 전체/일부를 복사
    Arrays.sort()
    
Object Oriented Programming(객체지향 프로그래밍)
    기존의 프로그래밍에 몇 가지 새로윤 규칙을 추가, 발전
    
    장점
        코드의 재사용성이 높음, 유지보수 용이
        코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경
        신뢰성이 높은 프로그래밍(제어자, 메소드 사용, 데이터 보호, 올바른값 유지, 코드의 중복 제거)

    클래스 : 객체를 정의해 놓은 것, 객체의 설게도
    객체(instance,object) : 실제로 존재하는 것

    당연히 직접 객체를 만들고 난 뒤 부터 사용 가능
    클래스를 정의하고 클래스를 통해 객체를 생성하는 이유는, 설계도를 통해서 제품을 만드는 이유와 같음
    
    객체의 구성요소
        속성과 기능(멤버)의 집합
        속성 : 변수, 기능 : 메소드

    인스턴스화 : 클래스로부터 객체를 만드는 과정
    객체는 모든 인스턴스를 대표하는 포괄적 의미, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 보다 강조
    
    하나의 소스파일에 하나의 클래스만을 정의하는것이 보통, 하나의 소스파일에 두 개 이상의 클래스를 정의하는것도 가능
    파일명은 public class의 이름과 일치해야 함

    변수 : 하나의 데이터를 저장할 수 있는 공간
    배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장
    구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장 -> Java에서는 Class로 대용
    클래스 : 구조체와 함수의 결합(구조체 -> Inner Class)

    객체지향 언어에서는 제어자를 이용해서 변수의 값을 직접 변경하지 못하게 하고, 메소드를 통해서 값을 변경하도록 작성 가능
    ex) 시,분,초 에서 시는 0~23의 값을 가져야 함, 지정된 값의 유효성을 점검할 수 있음

    ex) int hour1,hour2,hour3;
        int minute1,minute2,minute3;
        int second1,second2,second3;(X)

        Time t1 = new Time();
        Time t2 = new Time();
        Time t3 = new Time();(O)

    변수의 종류
        클래스 변수(static) : 클래스 영역, 클래스가 메모리에 올라갈 때 생성, 모든 인스턴스가 공통된 값(저장 공간)을 공유
        인스턴스 변수 : 클래스 영역, 인스턴스가 생성되었을 때 생성, 인스턴스마다 서로 다른 값(저장 공간)
        지역 변수 : 메서드, 생성자, 초기화 블럭 내부(클래스 영역 이외), 변수 선언문이 수행됐을 때 생성

    메소드의 리턴값은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다.


Call Stack
    메소드가 호출되면, 호출스택에 호출된 메소드를 위한 메모리가 할당, 이 공간에 지역변수/매개변수와 연산의 중간결과 저장
    메소드가 작업을 마치면 반환
    Call Stack의 맨 위에 있는 메소드가 현재 실행중인 메소드
    아래에 있는 메소드가 바로 위의 메소드를 호출한 메소드
    return type이 있는 메소드는 종료되면서 결과값을 자신을 호출한 메소드에게 반환
    대기상태에 있던 메소드는 넘겨받은 반환값으로 수행을 계속 진행

기본형 매개변수 : readonly
참조형 매개변수 : read and write 가능 -> https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value
 

static을 사용하는 경우
    static method
        클래스 메서드는 인스턴스 변수 사용 불가
        인스턴스와 관계가 없는 경우, 즉 인스턴스 변수/인스턴스 메서드를 사용하지 않는 경우 사용
    
    static member
        클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통(같은 값)으로 사용하는 것에 static
        static이 붙은 건 클래스가 메모리에 올라갈 때 이미 자동적으로 생성

같은 클래스에 속한 멤버(member, not Class)들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조/호출 가능
    단, 클래스(static) 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 함

오버로딩((method) Overloading)
    한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 갯수 또는 타입이 다르다면 같은 이름을 사용해서 정의 가능
    
    1. 메소드 이름이 같아야 함
    2. 매개변수의 갯수 또는 타입이 달라야 함(매개변수의 이름은 구별하지 않음)
    3. 반환 타입은 관계 없음(System.out.println 생각)
    
    매개변수의 순서만 다른 경우는 지양할 것
        long add(int a, long b)
        long add(long a, int b)
            add(3,3L)은 1번째, add(3L,3)은 2번째 호출 add(3,3)은 에러
    
    > 실무에서 적용한다면, 당연히 구별되게 최대한 혼동되지 않게, 심플하게 작성할 수 있어야 함
    > Optional Parameter : Optional<Integer> param 사용
            
생성자(constructor)
    인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드
    인스턴스 생성시에 실행되어야 하는 작업을 위해서도 사용
    생성자의 이름은 클래스의 이름과 같아야 하며, 리턴값이 없음

    연산자 new가 인스턴스를 생성, 생성자가 인스턴스를 생성하는 것이 아님(초기화 작업일 뿐)
    
    기본 생성자 : 자동 생성, 이미 생성된 생성자가 있다면 생성되지 않음
        Class(){}

    클래스를 생성할 때는 어떤 클래스를 생성할 것인지, 어떤 생성자를 사용할 것인지 결정해야 한다.

this
    생성자의 이름으로 클래스 이름대신 this를 사용
    한 생성자에서 다른 생성자를 호출할 때에는 반드시 첫 줄에서만 가능
    this.variable : 인스턴스 변수
    
    static은 this 사용 불가, 인스턴스가 생성되어 있을지 모름
    
    this : 인스턴스 자신을 가르키는 참조 변수, 인스턴스의 주소가 저장, 모든 인스턴스 메서드에 지역변수로 숨겨진채로 존재
    this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용
    
    this와 this()는 완전히 다름!

변수의 초기화   
    지역변수는 사용하기 전에 반드시 초기화
    멤버변수(클래스 변수와 인스턴스 변수), 배열의 초기화는 선택적(기본값이 들어감)
    boolean : false, 숫자 : 0, 참조형 : null

멤버변수(클래스 변수와 인스턴스 변수)의 초기화
    1. 클래스 변수 초기화 -> 인스턴스 변수 초기화
    2. 자동 초기화 -> 명시적 초기화 -> 초기화 블럭, 생성자

    명시적 초기화 : 선언과 동시에 초기화(int door=4;)
    초기화 블럭 : 클래스 초기화 블럭(static{}) / 인스턴스 초기화 블럭({})
    클래스 초기화 블럭은 한번만 실행되지만, 인스턴스 초기화 블럭은 인스턴스가 생성될 때마다 실행
    

상속
    기존의 클래스를 재사용하여 새로운 클래스를 작성, 코드를 공통적으로 관리할 수 있기에 유지보수 용이
    코드의 재사용성을 높이고 중복을 제거
    상속시 모든 멤버를 상속받음. 단, 생성자와 초기화 블럭은 상속되지 않음
    자바에서는 다중 상속이 불가능, 단일 상속만 가능 
        다중상속을 허용할 경우, 클래스 간 관계 매우 복잡해짐 + 다른 클래스로부터 상속받은 멤버간 이름이 같은 경우 구별 불가능
        불편한 점도 있지만 클래스 간 관계 명확, 코드 신뢰성 상승

포함관계
    포함 관계를 맺어주고 클래스를 재사용 가능
    한 클래스의 멤버 변수로 다른 클래스의 참조 변수를 선언

<cf>
    상속 : ~은 ~이다.(어느 종인지 그런 느낌인 듯)
    포함 : ~은 ~을 가지고 있다.

Object Class
    모든 클래스 상속계층도의 최상위에 있는 조상 클래스
    다른 클래스로부터 상속받지 않는 모든 클래스들은 자동적으로 Object 클래스로부터 상속받음
        SmartTv -> Tv -> Object
    
    Java의 모든 클래스는 Object의 메소드, 멤버를 사용할 수 있음(toString(), equals(),...)
    
오버라이딩(Overriding)
    조상으로부터 상속받은 메소드의 내용을 변경, 자손 클래스에 맞게 변경하는 것    
    새로운 메소드를 만드는 것 보다, overriding하면 조상 메소드에서도 사용하던 방식 그대로 사용
    
    1. 메소드의 내용만을 새로 작성하는 것, 메소드의 선언부(이름, 매개변수, 반환타입)는 조상의 것과 동일해야
    2. 접근 제어자는 조상 클래스의 메소드보다 좁은 범위로 변경할 수 없다. => 더 넓어야 한다.
    ex) 조상 : protected, 자손 : protected or public
    3. 조상 클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.

super
    자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용하는 변수
    super() : 조상의 생성자
    클래스 자신에 선언된 변수는 자신의 생성자가 초기화를 책임지도록 작성하는 것이 바람직
        부모에 선언된 변수는 부모의 생성자로 초기화 되도록 하기
    
package(패키지)
    패키지,클래스의 묶음(클래스 또는 인터페이스를 포함), 서로 관련된 클래스들 끼리 그룹 단위로 묶음
    패키지도 다른 패키지를 포함할 수 있음
    클래스가 물리적으로 하나의 클래스 파일(.class) 이듯이, 패키지는 물리적으로 하나의 디렉토리
    
    패키지의 선언
        클래스나 인터페이스의 소스파일(.java)의 맨 위에 package 패캐지명;
        하나의 소스파일에 단 한번만 선언
        대소문자 모두 가능하나, 소문자로 하는 것이 원칙
        모든 클래스는 반드시 하나의 패키지에 선언되어야 함, 선언하지 않는 것들도 모두 자바에서 기본적으로 제공하는 이름없는 패키지(unnamed package)에 속해있음
        
    클래스패스(classpath)
        A클래스가 com.A.B 패키지에 포함되어 있다면, 클래스 파일인 A.class는 com/A/B 폴더 안에 있어야 함
        패키지의 루트 디렉토리를 클래스패스에 포함시켜야 함
        환경변수에 CLASSPATH, 변수값에 루트 디렉토리를 적어야 함(구분자 : ;)

    import
        컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공
        모든 소스파일에서 import문은 package문 다음에, 클래스 선언문 이전에 위치해야 함
        import 패키지명.클래스명;
        import 패키지명.*;
            두 선언문 간의 실행 시 성능상의 차이는 없음
            해당 패키지에서 일치하는 클래스 이름을 찾는 정도만 함
        
        static import
            static 멤버를 호출할 때 클래스 이름을 생략할 수 있음
            특정 클래스의 static 멤버를 자주 사용할 때 편리

제어자(modifier)
    접근 제어자 : public, protected, (default), private
    그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
    
    하나의 대상에 대해 여러 제어자를 조합해서 사용 가능, 하지만 접근 제어자는 한가지만 사용 가능
    
    static
        클래스에 관계된 것, 인스턴스를 생성하지 않고도 사용 가능
        인스턴스 멤버를 사용하지 않는 것이 제일 큰 특징, 사용하지 않는다면 static으로 지정하는 것이 좋음

        static 멤버변수
            모든 인스턴스에 공통적으로 사용되는 클래스 변수
            인스턴스를 생성하지 않고도 사용 가능
            클래스가 메모리에 로드될 때 생성
        
        static 메소드
            인스턴스를 생성하지 않고도 호출이 가능한 static 메소드
            static 메소드 내에서는 인스턴스 멤버들을 직접 사용할 수 없음

    final : 마지막, 변경될 수 없는
        final 클래스
            변경할 수 없는, 확장될 수 없는 클래스
            다른 클래스의 조상이 될 수 없음(상속할 수 없음)
        
        final 메소드
            변경될 수 없는 메소드, final로 지정된 메소드는 오버라이딩 될 수 없음

        final 멤버변수 지역변수
            값을 변경할 수 없는 상수

    abstract : 추상의, 미완성의
        abstract 클래스
            클래스 내에 추상 메소드가 선언되어 있음을 의미
            미완성 설계도이므로, 인스턴스 생성 불가

        abstract 메소드
            선언부만 작성하고, 구현부는 작성하지 않는 추상 메소드임을 알림
        

접근제어자
    private : 같은 클래스 내에서만 접근 가능
    default : 같은 패키지 내에서
    protected : 같은 패키지 내에서, 다른 패키지의 자손클래스(패키지에 관계 없이 상속관계에 있는 자손클래스에서 접근할 수 있도록 하는 것이 제한 목적)에서 접근 가능
    public : 접근 제한 전혀 없음

    접근 제어자 지정되어 있지 않다면 default로 설정됨

캡슐화(encapsulation)
    클래스의 내부에 선언된 데이터를 보호하기 위해서 사용
    유효한 값을 유지하고, 외부에서 함부로 변경하지 못하도록 하기 위해 외부에서의 접근 제한, 복잡성 줄임
    클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버 변수나 부분작업을 처리하기 위한 메소드 등의 멤버를 클래스 내부에 숨김

    getter,setter
        setter에서 유효한 값에 대한 조건을 검사 후, 조건에 맞는 값일때만 값을 변경
        getter는 값을 반환

다형성(polymorphism)
    한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함
    조상클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조

    SmartTv s = new SmartTv(); //일반적
    Tv t = new SmartTv(); //타입 불일치, 조상 타입의 참조변수로 자손 인스턴스 참조
    
    t는 SmartTv 인스턴스 중에서 Tv 클래스의 멤버들(상속받은 멤버 포함)만 사용할 수 있음
    둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 갯수가 달라짐

    자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다
        실제 인스턴스보다 참조변수가 사용할 수 있는 멤버 개수가 더 많기 때문

    여러 종류의 객체를 하나의 배열로 다룰 수도 있게 됨

    
참조변수의 형변환
    서로 상속관계에 있는 클래스 사이에서만 형변환 가능, 조상에서 자손으로, 자손에서 조상으로, Object로 등등
    기본형의 형변환과 달리 참조형의 형변환은 변수에 저장된 값(주소값)이 변환되는 것이 아님

    조상타입으로의 형변환은 생략 가능 : 다룰 수 있는 멤버의 개수가 줄으므로 항상 안전

    ex)     Car
          /     \
    FireEngine  Ambulance

    FireEngine f = new FireEngine();
    Car c = f // Car c = (Car) f : 생략 가능
    f = (FireEngine) c;

    리모컨(참조변수)를 다른 종류의 것으로 바꾼는 것뿐
        사용할 수 있는 멤버 개수 조절

    instanceof
        어떤 타입에 대한 instanceof 연산의 결과가 true라는 것은 검사한 타입으로의 형변환이 가능하다는 것
        

Vector
    동적으로 크기가 관리되는 객체 배열

추상 클래스 : 미완성 설계도
    미완성 메소드를 포함하고 있다는 의미
    인스턴스 생성 불가
    상속을 통해서 자손클래스에 의해서만 완성될 수 있음
    
    ex) TV를 만든다 하더라도, 기능의 차이에 따라 여러 종류의 모델이 있지만 대부분의 기능은 비슷, 이런 경우에 추상 클래스를 생성

    추상 클래스롭터 상속받는 자손 클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메소드를 모두 구현해야 함
    추상 메소드 중 하나라도 구현하지 않는다면, 자손 클래스 역시 추상클래스로 지정해야 함

    상속이 자손 클래스를 만드는 데 조상 클래스를 사용하는 것이라면, 이와 반대로 추상화는 기존의 클래스의 공통 부분을 뽑아내서 조상 클래스를 만드는 것
    상속 계층도를 따라 내려갈수록 클래스는 점점 기능이 추가되어 구체화, 올라갈수록 추상화(DB super type과 유사한 듯)

인터페이스(Interface) : 기본 설계도
    일종의 추상 클래스, 추상화 정도가 높아서 일반 메소드 또는 멤버 변수를 구성원으로 가질 수 없음
    오직 추상 메소드와 상수만 멤버로 가질 수 있음

    접근 제어자로 public 또는 default만 사용 가능
    모든 멤버 변수는 public static final, 생략 가능
    모든 메소드는 public abstract, 생략 가능(단, static 메소드와 default 메소드는 예외)

    상속 가능, 다중 상속 가능
    
    클래스가 인터페이스를 상속받아서 추상 메소드를 구현해야 함, 클래스의 상속과 같지만 "implements" keyword 사용
    상속과 구현을 동시에도 가능

    인터페이스를 이용한 다형성
        해당 인터페이스 타입의 참조 변수로 이를 구현한 클래스의 인스턴스 참조 가능, 인터페이스 타입으로의 형변환도 가능
        인터페이스는 메소드의 매개변수 타입으로도 사용 가능
            해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 한다는 의미
        메소드의 리턴타입으로 인터페이스를 지정 가능
            메소드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 의미

    장점
        개발시간 단축
            메소드를 호출하는 쪽에서는 메소드의 선언부와 역할만 알면 됨, 개발 동시 진행 가능
        표준화 가능
            일관화, 정형화
        서로 관계없는 클래스들에게 관계를 맺을 수 있음
            서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않은 서로 어떠한 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 강제
        독립적 프로그래밍 가능
            클래스와 클래스 간의 직접적인 관계를 인터페이스를 이용해 간접적 관계로 변경
            한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적 프로그래밍 가능
            
디폴트 메소드(default method)
    인터페이스에 추상 메소드만 선언할 수 있었는데, 디폴트, 스태틱 메소드도 추가할 수 있게 됨
    인터페이스에 추상 메소드를 추가한다는 것은, 기존의 이 인터페이스를 구현한 모든 클래스에서 새로 추가된 메소드를 구현해야 함
    인터페이스가 변경되지 않으면 제일 좋겠지만, 아무리 설계를 잘해도 언젠가 변경은 발생하기 때문에 탄생
    
    디폴트 메소드는 추상 메소드의 기본적인 구현을 제공, 추상 메소드가 아니기 때문에 해당 인터페이스를 구현한 클래스를 변경하지 않아도 됨
    추상 메소드와 달리 일반 메소드처럼 몸통{}이 있어야 함, 접근제어자는 public

    새로 추가된 디폴트 메소드가 기존의 메소드와 이름이 중복되어 충돌 가능성 있음
    필요한 쪽의 메소드와 같은 내용으로 오버라이딩
    
    디폴트 메소드는 인터페이스에서 구현되는 함수라고 생각하면 될 듯,
    인터페이스를 implements만 해도 그 메소드를 호출할 수 있음

내부 클래스
    클래스 내에 선언된 클래스, 두 클래스가 서로 긴밀한 관계인 경우 사용
    내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근 가능, 캡슐화
    내부 클래스는 자신을 포함하고 있는 외부 클래스를 제외하고는 다른 클래스에서 잘 사용되지 않는 것

    내부 클래스는 마치 변수를 선언하는 것과 같은 위치에 선언할 수 있음
    abstract, final 같은 제어자 뿐만 아니라 멤버변수들처럼 private, protected의 접근제어자도 사용 가능

    인스턴스 클래스
        외부 클래스의 멤버변수 선언 위치에 선언, 외부 클래스의 인스턴스 멤버처럼 다루어짐

    스태틱 클래스
        외부 클래스의 멤버변수 선언 위치에 선언, 외부 클래스의 스태틱 멤버처럼 다루어짐
        주로 외부 클래스의 static 멤버, static 메소드에서 사용될 목적으로 선언

    지역 클래스
        외부 클래스의 메소드나 초기화 블럭 안에 선언, 선언된 영역 내부에서만 사용

    익명 클래스
        클래스의 선언과 객체의 생성을 동시에 하는 일회용 클래스
    
    내부 클래스 중에서 스태틱 클래스만 스태틱 멤버를 가질 수 있음, final static(상수)은 사용 가능

    인스턴스 클래스는 외부 클래스의 인스턴스 멤버를 객체 생성 없이 바로 사용 가능, 스태틱 클래스는 외부 클래스의 인스턴스 멤버를 객체생성 없이 사용 불가
    인스턴스 클래스는 스태틱 클래스의 멤버들을 객체생성 없이 사용할 수 있지만 스태틱 클래스에서는 인스턴스 클래스의 멤버들을 객체생성 없이 사용 불가

    외부 클래스가 아닌 다른 클래스에서 내부 클래스를 생성하고 내부 클래스의 멤버에 접근할 수 있긴 하지만, 그런 경우 내부 클래스로 선언하면 안되는 경우

    내부 클래스와 외부 클래스에 선언된 변수의 이름이 같을 때, 변수 앞에 this(내부)또는 외부 클래스명.this(외부)를 붙여서 서로 구별 가능

    지역 클래스는 외부 클래스의 인스턴스 멤버와 static 멤버를 모두 사용할 수 있으며 지역 클래스가 포함된 메소드에 정의된 지역변수도 사용 가능
    단, final이 붙은 지역변수만 접근 가능, 그 이유는 메소드가 수행을 마쳐서 지역변수가 소멸된 시점에도, 지역 클래스의 인스턴스가
    소멸된 지역변수를 참조하려는 경우가 발생할 수 있기 떄문

 프로그램 오류
    컴파일 에러 : 컴파일 시 발생 에러
    런타임 에러 : 실행 시 발생 에러
    논리적 에러 : 실행은 되지만, 의도와 다르게 동작
    에러 : 심각한 오류
    예외 : 다소 미약한 오류, 프로그램 코드에 의해서 수습될 수 있음

    Object - Throwable - Exception
                       - Error

    예외 클래스는 Exception 클래스와 그 자손들, RuntimeException 클래스와 그 자손들로 나뉠 수 있음
    RuntimeException은 주로 프로그래머의 실수로 발생하는 예외가 많음
    Exception은 사용자의 실수와 같은 외적인 요인에 의해 발생하는 경우가 많음

    예외처리
        프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드 작성
        프로그램의 비정상 종료를 막고 정상적인 실행4상태 유지
        발생한 예외를 처리하지 못하면 프로그램은 비정상적 종료, 처리되지 못한 예외는 JVM의 예외처리기가 받아서 예외 출력

        try블럭 내에서 예외가 발생한 경우
        1. 발생한 예외와 일치하는 catch 블럭이 있는지 확인
        2. 일치하는 catch 블럭을 찾게 되면, 그 catch 블럭 내의 문장들을 수행하고 전체 try-catch 문을 빠져나간다.
        3. 일치하는 catch 블럭을 찾지 못하면, 예외는 처리되지 않는다.
        4. try 블럭 내에서 예외가 발생하지 않은 경우 catch를 거치지 않고 빠져나가서 수행한다.

        예외가 발생하면, 발생한 예외에 해당하는 클래스의 인스턴스가 만들어 진다.
        첫 번째 catch 블럭부터 차례로 내려가면서 catch 블럭의 () 내에 선언된 참조변수의 종류와 생성된 예외 클래스의 인스턴스에
        instanceof 연산자를 사용해서 검사하게 되는데, 검사결과가 true인 catch 블럭을 만날 때까지 검사

        printStackTrace() : 예외발생 당시의 호출 스택(Call stack)에 있었던 메소드의 정보와 예외 메세지를 화면에 출력
        getMessage() : 발생한 예외클래스의 인스턴스에 저장된 메세지를 얻을 수 있음



Ch09 java.lang패키지와 유용한 클래스

java.lang package의 클래스들은 import문 없이 사용 가능

Object Class
    protected Object Clone()
    public boolean equals(Object o) : 같고 다름을 참조변수의 값으로 판단, 내부의 값이 같은 걸 판단하는 게 아님
    protected void finalize() : 객체가 소멸될 때 가비지 컬렉터에 의해 자동적 호출, 이 때 수행되어야 하는 코드가 있을 때 오버라이딩
    public Class getClass() : Class 인스턴스 반환
    public int hashCode()
    public String toString()

    객체 자신을 사용하려고 기다리는 스레드를 깨움
        public void notify()
        public void notifyAll()

    다른 스레드가 notify()나 notifyAll()를 호출할 때까지 현재 쓰레드를 기다림
        public void wait()
        public void wait(long timeout)

hash code
    객체의 주소값을 이용해서 해시코드를 만들어서 반환, 서로 다른 두 객체는 절대 같은 해쉬코드를 가질 수 없음
    String 클래스는 문자열의 내용이 같으면 동일한 hashCode를 반환하도록 overriding

String 클래스
    immutable Class
    문자열의 내용이 바뀔 경우, 인스턴스 내 문자열이 바뀌는 것이 아닌, 새로운 문자열이 담긴 String 인스턴스 생성
    문자간 결합, 추출 등 변경이 많은 경우 StringBuffer Class 이용
    
    String Class 생성
        String str1="abc";
        String str2="abc";
        String str3=new String("abc");
        String str4=new String("abc");

        new 연산자에 의해서 새로운 메모리 할당, 인스턴스가 할당, str3와 str4는 각각 다른 인스턴스를 참조
        str1과 str2는 같은 인스턴스 참조

        자바 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시 클래스 파일에 저장
        클래스 파일이 클래스 로더에 의해 메모리에 올라갈 때, 클래스 파일의 리터럴들이 JVM내의 상수 저장소에 저장
        같은 리터럴을 가르킬 경우, 굳이 인스턴스를 새로 생성하지 않는 것

    equals() 사용 시, 문자열의 내용을 비교
    
    String s = ""; == char[] s = new char[0];

    Methods
        생성자
            String(String s)
            String(char[] value)
            String(StringBuffer buf)
        
        char charAt(int index)
        int compareTo(String str) : 사전 순서 비교(같으면 0, 이전이면 음수 이후면 양수)
        String concat(String str)
        boolean contains(String s)

        boolean endsWith(String suffix) : 지정된 문자열로 끝나는지 검사
        boolean startsWith(String prefix)

        boolean equals(Object o)
        boolean equalsIgnoreCase(String str)
        
        int indexOf(int ch)
        int indexOf(int ch, int pos) : pos부터 확인
        int indexOf(String str)
        int lastIndexOf(int ch)
        int lastIndexOf(int ch, int pos)
        int lastIndexOf(String str)
        
        String intern() : 문자열을 상수풀에 등록
        
        int length()
        
        String replace(char old, char new)
        String replace(CharSequence old, CharSequence new)
        String replaceAll(String regex, String replacement)
        String replaceFirst(String regex, String replacement)

        String[] split(String regex)

        String substring(int begin)
        String substring(int begin, int end) : begin 포함, end 미포함
        
        String toLowerCase()
        String toUpperCase()
        
        String toString()
        String trim()

        static String valueOf(아무거나) : 지정된 값을 문자열로 변환하여 반환, 참조변수의 경우 toString() 호출한 결과 반환
        
        join(String delimiter, arr);
    
    문자열과 기본형 간의 변환
        기본형 -> 문자열
            int i = 100;
            String str = i+"";
            String str2 = String.valueOf(i);

        문자열 -> 기본형
            int i = Integer.parseInt("100".trim());
            int i = Integer.valueOf("100".trim());

            공백이 있으면 오류가 발생하므로, trim등과 같이 써주는 습관을 들이자

StringBuffer
    String 클래스는 인스턴스를 생성할 때 지정한 문자열 변경 불가
    StringBuffer는 변경 가능

    내부적으로 문자열 편집을 위한 버퍼를 가지고 있음
    편집중인 문자열이 버퍼의 길이를 넘어서게 되면, 버퍼의 길이를 늘려주는 작업이 추가로 진행됨
        배열의 길이가 불가하므로, 새로운 배열을 만들어서 지금까지 작성했던 내용을 복사

    변경
        StringBuffer sb = new StringBuffer("abc");
        append의 return Type : StringBuffer
        sb.append("12").append("34"); // 가능
            sb.append("12")는 StringBuffer를 Return하므로, 다시 이어서 뒤에 붙이는게 가능

    String 클래스에서는 equals를 overriding, 값을 비교
    StringBuffer는 equals를 overriding 하지 않음
        비교를 위해서는, toString() 이후 equals() 호출

    Method
        StringBuffer() : default 16bytes
        StringBuffer(int length)
        StringBuffer(String str)

        StringBuffer append()
        StringBuffer insert(int pos, 아무거나)
        
        int capacity() : return buffer size
        int length() : 문자열의 길이
        
        char charAt(int index)
        StringBuffer delete(int start, int end) : start이상 end미만
        StringBuffer deleteCharAt(int index)
        
        StringBuffer replace(int start, int end, String str) : start 이상 end 미만을 str로 바꿈
        StringBuffer reverse()

        void setCharAt(int index, char ch)
        void setLength(int newLength) : newLength로 문자열의 길이 변경

        String subString(int start)
        String subString(int start, int end)

StringBuilder
    StringBuffer는 멀티스레드에 안전(thread safe)
        동기화로 인한 성능 저하

    StringBuilder는 StringBuffer에서 thread의 동기화만 뺀 기능

Math
    abs
    ceil : 올림
    floor : 내림
    round : 반올림
    random
    min
    max

Wrapper Class
    8개의 기본형 -> 객체로 다루지 않음, 성능 향상
    기본형 값을 객체로 변환하기 위해서 Wrapper Class 사용
    래퍼 클래스의 생성자는 매개변수로 문자열이나 각 자료형의 값들을 인자로 받음
        반드시 맞춰서 줘야 함
    equals() overriding, 가지고 있는 값 비교 

Number Class
    기본형 중에서 숫자와 관련된 래퍼 클래스들은 모두 Number Class의 자손
    BigInteger, BigDecimal 등 큰 수를 다룰 수 있는 Class도 있음

AutoBoxing
    원시 타입이 Wrapper 클래스 타입이ㅡ 파라미터를 받는 메소드 통과
    원시 타입이 Wrapper 클래스의 변수로 할당

    컴파일러가 자동으로 변환해줌
        //int sum = i + integer.intValue();
        int sum = i + integer;


        //Integer integer = Integer.valueOf(i);
        Integer integer = (Integer) i;
        
        //Object obj = (Object)Integer.valueOf(i);
        Object obj = (Object) i;

Unboxing
    Wrapper 클래스 타입이 원시 타입의 파라미터를 받는 메소트 통과
    Wrapper 클래스 타입이 원시 타입의 변수로 할당



Ch10 날짜와 시간 형상화

Ch11 컬렉션 프레임워크

컬렉션 프레임워크(Collection Framework)
    데이터군을 저장하는 클래스들을 표준화한 설계(data group을 다루고 표현하기 위한 단일화된 구조(architecture))
    컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set, Map 인터페이스 중 하나 구현

Collection
    List와 Set의 공통적인 부분을 뽑아서 만들어짐
    
    methods
        컬렉션에 추가
            boolean add(Object or Collection)
        
        모든 객체 삭제
            void clear()
        
        객체에 포함 여부 확인
            boolean contains(Object o)
            boolean containsAll(Collection c)

        동일한 Collection인지 비교 -> 주소값 비교
            boolean equals(Object o)

        hash code 반환
            int hashCode()
        
        비어있는지 확인
            boolean isEmpty()

        iterator 얻어서 반환
            iterator iterator()

        지정된 객체 삭제
            boolean remove(Object o)
            
        지정된 Collection에 포함된 객체들 삭제
            boolean removeAll(Collection c)
        
        지정된 Collection에 포함된 객체만 남기고 다른 객체들은 Collection에서 삭제
            boolean retainAll(Collection c)

        객체의 개수 반환
            int size()
        
        저장된 객체를 객체 배열로 반환
            Object[] toArray()

        지정된 배열에 Collection의 객체 저장해서 반환
            Object[] toArray(Object[] o)


List
    순서가 있는 데이터의 집합, 데이터 중복 허용
    구현 클래스 : ArrayList, LinkedList, Stack, Vector

               List
        /        |         \
    Vector  ArrayList  LinkedList
       |
    Stack

    methods
        지정된 위치에 객체또는 컬렉션에 포함된 객체 추가
            void add(int index, Object element)
            boolean addAll(int index, Collection c)

        지정된 위치에 있는 객체 반환
            Object get(int index)

        지정된 객체의 위치 반환
            int indexOf(Object o)

        지정된 객체의 마지막 위치 반환
            int lastIndexOf(Object o)            

        List의 객체에 접근할 수 있는 ListIterator 반환
            ListIterator listIterator()
            ListIterator listIterator(int index)

        지정된 위치에 있는 객체 삭제, 반환
            Object remove(int index)

        지정된 위치에 객체 저장
            Object set(int index, Object element)            

        지정된 비교자로 List 정렬
            void sort(Comparator c)

        지정된 범위에 있는 객체 반환
            List subList(int fromIndex, int toIndex)


Set
    순서를 유지하지 않는 데이터 집합, 중복 허용 X
    구현 클래스 : HashSet, TreeSet

    methods
        지정된 객체 또는 Collection의 객체들을 추가
            boolean add(Object o)
            boolean addAll(Collection c)
        
        Collection의 모든 객체 삭제
            void clear()
        
        지정된 객체 또는 Collection의 객체들이 Collection에 포함되어 있는지 확인
            boolean contains(Object o)
            boolean containsAll(Collection c)

        동일한 Collection인지 비교
            boolean equals(Object o)

        hash code 반환
            int hashCode()
        
        비어있는지 확인
            boolean isEmpty()

        Iterator 얻어서 반환
            Iterator iterator()

        지정된 객체 삭제
            boolean remove(Object o)
        
        지정된 Collection에 포함된 객체들 삭제
            boolean removeAll(Collection c)
        
        지정된 Collection에 포함된 객체들만 남기고 다른 객체들은 Collection에서 삭제
            boolean retainAll(Collection c)
        
        객체의 개수 반환
            int size()
        
        객체 배열로 반환
            Object[] toArray()
            Object[] toArray(Object[] a)
        

Map
    키와 값의 쌍으로 이루어진 데이터의 집합
    순서 유지 X, 키 중복 허용 X, 값은 중복 허용
    구현 클래스 : HashMap, TreeMap, HashTable, Properties
    
                    Map
        /           |                \
    HashTable      HashMap          SortedMap
                    |                 |
                LinkedHashMap     TreeMap

    Methods
        모든 객체 삭제
            void clear()
        
        지정된 key 객체와 일치하는 Map의 key객체가 있는지 확인
            boolean containsKey(Object key)
        
        지정된 value 객체와 일치하는 Map의 value 객체가 있는지 확인
            boolean containsValue(Object value)
        
        Map에 저장되어 있는 key-value 쌍을 Map.Entry타입의 객체로 저장한 Set으로 반환
            Set entrySet()
        
        동일한 Map인지 비교
            boolean equals(Object o)
        
        지정한 key객체에 대응하는 value객체를 찾아서 반환
            Object get(Object key)
        
        hash code
            int hashCode()

        비어있는지 확인
            boolean isEmpty()
    
        모든 key 반환
            Set keySet()
        
        Map에 value객체를 key객체에 연결하여 저장
            Object put(Object key, Object value)
        
        지정된 Map의 모든 key-value 쌍 추가
            void putAll(Map t)
        
        지정한 key 객체와 일치하는 key-value 객체를 삭제
            Object remove(Object key)
        
        Map에 저장된 모든 key-value 쌍의 개수 반환
            int size()

        Map에 저장된 모든 value 객체 반환
            Collection values()

구현 Class

ArrayList
    Object 배열을 이용해서 순차적으로 데이터 저장
    데이터 저장 순서 유지, 중복 허용
    
    ArrayList의 추가와 삭제 > 배열의 중간 값을 변경할 경우 이런 과정을 거쳐야 하므로, 소요가 꽤 드는 작업
        삭제할 데이터의 아래에 있는 데이터를 한칸씩 위로 복사, 삭제할 데이터 덮어씀
        데이터가 모두 한칸씩 위로 이동, 마지막 데이터 null로 변경
        size값 변경

    List 인터페이스 구현했으므로 기능들 다 들어있음
        
        ArrayList 생성
            ArrayList()
            ArrayList(Collection c)
            ArrayList(int initialCapacity)
        
        저장
            boolean add(Object o) => same as push
            void add(int index,Object element)
            boolean addAll(Collection c)
            boolean addAll(int index, Collection c)
            Object set(int index, Object element)

        삭제
            void clear()
            Object remove(int index)
            boolean remove(Object o)
            boolean removeAll(Collection c) : 동일한 객체 제거
            boolean retainAll(Collection c) : 동일한 객체 유지

        복제
            Object clone()
        
        포함 여부
            boolean contains(Object o)
        
        반환
            Object get(int index)
            int indexOf(Object o)
            int lastIndexOf(Object o)
            boolean isEmpty()
            Iterator iterator()
            ListIterator listIterator()
            ListIterator listIterator(int index) : index부터 시작하는 iterator
            int size()
            List subList(int fromIndex,int toIndex)
            Object[] toArray()
            
        정렬/정리
            void sort(Comparator c)
            void trimToSize() : 빈 공간 제거

        
LinkedList
    ArrayList
        크기 변경 불가, 비순차적 데이터의 추가 또는 삭제에 많은 시간 소요
        인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기
        주소에 대한 접근이 용이하기에, 접근 시간은 빠르지만 추가 삭제 느림
    
    LinkedList
        Link를 따라서 각 Node에 접근하므로, 접근 시간은 느리지만, 추가 삭제는 빠름
    

Stack - Stack이 구현체
    LIFO
    
    methods
        boolean empty()
        Object peek()
        Object pop()
        Object push(Object item)
        int search(Object o) : 못찾으면 -1 반환


Queue - LinkedList가 구현체
    FIFO
    
    추가
        boolean add(Object o) : Queue에 추가
        boolean offer(Object o) : Queue에 객체를 저장
        
    삭제
        Object remove() : 객체를 꺼내 반환
        Object poll() : Queue에서 객체를 꺼내서 반환

    조회
        Object element() => peek
        Object peek()

Iterator
    컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스

ListIterator
    Iterator에 양방향 조회기능 추가(List를 구현한 경우에만 가능)

Enumeration
    Iterator 구버전

    Set에서 Iterator를 사용할 경우, Key또는 Value를 각각 따로 얻어온 후에 iterator()를 호출해야 함
        map.entrySet().iterator();

    
Arrays
    
    복사
        Arrays.copyOf(arr, int number)
        Arrays.copyOfRange(arr, int start, int last)

    채우기
        int[] arr = new int[5];
        Arrays.fill(arr,9); // arr=[9,9,9,9,9]
        Arrays.setAll(arr,(i)->(int)(Math.random()*5)+1);

    정렬/검색
        int[] arr = {3,2,1,4,5};
        Arrays.sort(arr);
        int idx = Arrays.binarySearch(arr,2);
            이분탐색이므로 반드시 정렬된 상태에서 동작
    
    비교/출력
        일차원 배열 출력 : toString()
        다차원 배열 출력 : deepToString()

        비교(값 비교)
        일차원 배열 비교 : Arrays.equals()
        다차원 배열 비교 : Arrays.deepEquals()

    배열을 List로 변환
        List list = Arrays.asList(new Integer[]{1,2,3,4,5});
        List list = Arrays.asList(1,2,3,4,5);
            위의 두 경우에는, List의 크기를 변경할 수 없으며 추가 삭제 불가능

        List list = new ArrayList(Arrays.asList(1,2,3,4,5));

Comparator, Comparable
    인터페이스로 컬렉션을 정렬하는데 필요한 메소드 정의

