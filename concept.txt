Java
    객체지향 프로그래밍 언어
        상속, 캡슐화, 다형성
    OS에 독립적, OS에 따라서 전혀 프로그램을 바꾸지 않아도 실행 가능
        Java Virtual Machine과 통신, JVM이 자바 응용프로램으로부터 전달받은 명령을 해당 운영체제가 이해할 수 있도록 변환하여 전달
        JVM은 OS에 종속적이라서 여러 운영체제에 설치할 수 있는 서로 다른 버전의 JVM 제공
    자동 메모리 관리
        가비지 컬렉터가 자동으로 메모리를 관리
    네트워크와 분산처리 지원
    풍부한 클래스 라이브러리(JAVA API)
    멀티쓰레드 지원
        여러 쓰레드에 대한 스케쥴링을 자바 인터프리터가 담당
    동적 로딩 지원
        실행 시에 모든 클래스가 로딩되지 않고, 필요한 시점에 클래스를 로딩하여 사용
        일부 클래스가 변경되어도 전체 애플리케이션을 다시 컴파일하지 않음, 비교적 유연한 처리

JVM(Java Virtual Machine)
    일반 애플리케이션의 코드는 OS만 거치고 HW로 전달
    JAVA는 JVM을 한 번 더 거치기 때문에 속도가 느리다는 단점
        바이트 코드(컴파일 된 자바코드)를 하드웨어의 기계어로 바로 변환해주는 JIT(Just In Time) 컴파일러와 향상된 최적화 기술이 적용되어서 속도 빨라짐

    JDK : JVM + Java API + development tools
    A.java => (javac.exe[java compiler]) => A.class => (java.exe[java interpreter]) => execute

    모든 코드는 클래스 안에 존해애햐 하며, 서로 관련된 코드들을 그룹으로 나누어 별도의 클래스 구성
    클래스들이 모여서, Java Application
    모든 클래스가 main method를 가지고 있어야 하는 것은 아니지만, 하나의 Java App에는 main method를 포함한 클래스가 반드시 하나는 존재해야
    main method : Java App의 시작점
    작성된 Java App을 실행할 때는, java.exe 다음에 main method를 포함한 클래스의 이름을 적어줘야 한다.

Java Application의 실행 과정
    1. 프로그램의 실행에 필요한 클래스(*.class)를 로드
    2. 클래스 파일 검사
    3. 지정된 클래스에서 main method 호출

변수
    int, long
    float, double : 실수 기본형은 double, float : 7자리까지 오차 없음, double은 15자리까지 오차 없음
    char, String : 'c'(character), "String"

상수
    final int variable = 4 => (literal);
    일단 상수에 값이 저장된 이후에는 변경 불가, 선언 후 나중에 할당 가능
    리터럴 : 그 자체로 값을 의미하는 것

리터럴의 타입과 접미사
    리터럴에도 타입이 존재, 리터럴에 접미사를 붙여서 타입을 구분
    정수 기본형은 int, long타입을 쓰고 싶다면, L을 붙임(425L)
    실수 기본형은 double, float타입을 쓰고 싶다면, F를 붙임
    byte와 short는 접미사 없음
    8진수 : 접두사 0, 16진수 : 접두사 0x
    정수형 리터럴의 중간에 _를 넣을 수 있음 (1_000 == 1000)

문자 리터럴과 문자열 리터럴
    char 리터럴은 안에 반드시 하나의 문자 필요
    String 리터럴은 안에 공백 가능
    String은 객체
    문자열 + any type = 문자열

자바는 C언어와 같이 참조형에 대한 연산 불가, 실제 연산에 사용되는것은 모두 기본형 변수

printf => C랑 같음, formatted print
    %d : 10진
    %x : 16진수
    %f : 부동소수점
    %c : 문자
    %s : string

타입이 정해져 있으므로, 오버플로우에 주의하자
    최솟값에서 1빼면 최댓값이 되고, 최댓값에서 1을 더하면 최솟값이 된다

타입 변환
    숫자 -> 문자

연산자
    산술 연산자 : + - * / % << >>
    비교 연산자 : < > <= >= == !=
    논리 연산자 : && || ! & | ^ ~
    대입 연산자 : =
    형변환 연산자 : (type)
    삼항 연산자 : ?
    타입체크 : instanceof

    우선순위 : 산술 > 비교 > 논리 > 대입, 단항 > 이항 > 삼항

    자동 형변환
        float f = 1234;
            1234를 float형태로 바꾸어야, 자동으로 형변환됨
            기존의 값을 최대한 보존할 수 있는 타입으로 자동 형변환
            표현 범위가 좁은 타입에서 넓은 타입으로 형변환 하는 경우에는, 넓은 쪽으로 변환

        큰 타입에서 작은 타입으로의 형 변환은 값 손실 발생 가능(정수형 -> 실수형 포함)
        (byte -> short -> int -> long -> float -> double)
        
        float과 int의 연산에서, int가 float으로 바뀌고, float과 float의 연산으로 바뀜
    
    산술 변환
        1. 두 피연산자의 타입을 같게 일치 시킴(보다 큰 타입으로 일치)
        2. 피연산자의 타입이 int보다 작은 타입이면 int로 변환
            int가 가장 자연스러운 타입
    
    항상 변수의 타입과 리터럴의 타입에 대해서 따로 생각하자!

    등가 비교 연산자 ==,!=
        기본형의 경우, 변수에 저장되어 있는 값이 같은지
        참조형의 경우, 객체의 주소값을 저장하므로 두 개의 피연산자의 주소가 같은지

    문자열의 비교
        equals(), ==사용 불가
    
    복합 대입 연산자
        i *= 10 + j;
        가장 마지막에 이루어짐, i = i * (10+j) 와 같은 의미


Switch
    1. 조건식을 먼저 계산한 다음, 그 결과와 일치하는 case문으로 이동
    2. 이후의 문장들 수행
    3. break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나감

    switch문의 조거신 결과는 정수 또는 문자열이어야 함
    case문의 값은 정수 상수, 문자열만 가능하며 중복되지 않아야 함

난수
    Math.random() : 0이상 1미만 double return

continue
    while문에서 continue는 조건식으로 이동
    for문에서 continue는 증감식으로 이동

배열(Array)
    같은 타입의 변수를 하나의 묶음으로 다루는 것
    배열을 다루는 데 필요한 참조변수일 뿐 저장하기 위한 공간이 아님

    변수 타입에 따른 기본값
        boolean : false
        char : \u0000
        byte,short,int : 0
        long : 0L
        float : 0.0f
        double 0.0d 또는 0.0
        참조형(객체) : null
    
String : char배열에 기능을 추가한 것
    메소드
        charAt() : 해당위치에 있는 문자 반환
        length()
        substring(from,to) : to 포함 안됨
        equals()
        toCharArray()

Arrays method
    Arrays.toString() : 문자열로 편하게 출력
    Arrays.equals() : 배열에 저장된 모든 요소(참조값이 아닌, 실제 들어있는값)를 비교
    Arrays.copyOf()/copyOfRange() : 배열 전체/일부를 복사
    Arrays.sort()
    
Object Oriented Programming(객체지향 프로그래밍)
    기존의 프로그래밍에 몇 가지 새로윤 규칙을 추가, 발전
    
    장점
        코드의 재사용성이 높음, 유지보수 용이
        코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경
        신뢰성이 높은 프로그래밍(제어자, 메소드 사용, 데이터 보호, 올바른값 유지, 코드의 중복 제거)

    클래스 : 객체를 정의해 놓은 것, 객체의 설게도
    객체(instance,object) : 실제로 존재하는 것

    당연히 직접 객체를 만들고 난 뒤 부터 사용 가능
    클래스를 정의하고 클래스를 통해 객체를 생성하는 이유는, 설계도를 통해서 제품을 만드는 이유와 같음
    
    객체의 구성요소
        속성과 기능(멤버)의 집합
        속성 : 변수, 기능 : 메소드

    인스턴스화 : 클래스로부터 객체를 만드는 과정
    객체는 모든 인스턴스를 대표하는 포괄적 의미, 인스턴스는 어떤 클래스로부터 만들어진 것인지를 보다 강조
    
    하나의 소스파일에 하나의 클래스만을 정의하는것이 보통, 하나의 소스파일에 두 개 이상의 클래스를 정의하는것도 가능
    파일명은 public class의 이름과 일치해야 함

    변수 : 하나의 데이터를 저장할 수 있는 공간
    배열 : 같은 종류의 여러 데이터를 하나의 집합으로 저장
    구조체 : 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장
    클래스 : 구조체와 함수의 결합

    객체지향 언어에서는 제어자를 이요해서 변수의 값을 직접 변경하지 못하게 하고, 메소드를 통해서 값을 변경하도록 작성 가능
    ex) 시,분,초 에서 시는 0~23의 값을 가져야 함, 지정된 값의 유효성을 점검할 수 있음

    ex) int hour1,hour2,hour3;
        int minute1,minute2,minute3;
        int second1,second2,second3;(X)

        Time t1 = new Time();
        Time t2 = new Time();
        Time t3 = new Time();(O)

    변수의 종류
        클래스 변수(static) : 클래스 영역, 클래스가 메모리에 올라갈 때 생성, 모든 인스턴스가 공통된 값(저장 공간)을 공유
        인스턴스 변수 : 클래스 영역, 인스턴스가 생성되었을 때 생성, 인스턴스마다 서로 다른 값(저장 공간)
        지역 변수 : 메서드, 생성자, 초기화 블럭 내부(클래스 영역 이외), 변수 선언문이 수행됐을 때 생성

    메소드의 리턴값은 반환타입과 일치하거나 적어도 자동 형변환이 가능한 것이어야 한다.


Call Stack
    메소드가 호출되면, 호출스택에 호출된 메소드를 위한 메모리가 할당, 이 공간에 지역변수/매개변수와 연산의 중간결과 저장
    메소드가 작업을 마치면 반환
    Call Stack의 맨 위에 있는 메소드가 현재 실행중인 메소드
    아래에 있는 메소드가 바로 위의 메소드를 호출한 메소드
    return type이 있는 메소드는 종료되면서 결과값을 자신을 호출한 메소드에게 반환
    대기상태에 있던 메소드는 넘겨받은 반환값으로 수행을 계속 진행

기본형 매개변수 : readonly
참조형 매개변수 : read and write, 인스턴스의 주소가 복사

static을 사용하는 경우
    static method
        클래스 메서드는 인스턴스 변수 사용 불가
        인스턴스와 관계가 없는 경우, 즉 인스턴스 변수/인스턴스 메서드를 사용하지 않는 경우 사용
    
    static member
        클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통(같은 값)으로 사용하는 것에 static
        static이 붙은 건 클래스가 메모리에 올라갈 때 이미 자동적으로 생성

같은 클래스에 속한 멤버들 간에는 별도의 인스턴스를 생성하지 않고도 서로 참조/호출 가능
단, 클래스(static) 멤버가 인스턴스 멤버를 참조 또는 호출하고자 하는 경우에는 인스턴스를 생성해야 함

오버로딩((method) Overloading)
    한 클래스 내에 이미 사용하려는 이름과 같은 이름을 가진 메서드가 있더라도 매개변수의 갯수 또는 타입이 다르다면 같은 이름을 사용해서 정의 가능
    
    1. 메소드 이름이 같아야 함
    2. 매개변수의 갯수 또는 타입이 달라야 함(매개변수의 이름은 구별하지 않음)
    3. 반환 타입은 관계 없음(System.out.println 생각)
    
    매개변수의 순서만 다른 경우는 지양할 것
        long add(int a, long b)
        long add(long a, int b)
            add(3,3L)은 1번째, add(3L,3)은 2번째 호출 add(3,3)은 에러
            
생성자(constructor)
    인스턴스가 생성될 때 호출되는 인스턴스 초기화 메소드
    인스턴스 생성시에 실행되어야 하는 작업을 위해서도 사용
    생성자의 이름은 크래스의 이름과 같아야 하며, 리턴값이 없음

    연산자 new가 인스턴스를 생성, 생성자가 인스턴스를 생성하는 것이 아님(초기화 작업일 뿐)
    
    기본 생성자 : 자동 생성, 이미 생성된 생성자가 있다면 생성되지 않음
        Class(){}

    클래스를 생성할 때는 어떤 클래스를 생성할 것인지, 어떤 생성자를 사용할 것인지 결정해야 한다.

this
    생성자의 이름으로 클래스 이름대신 this를 사용
    한 생성자에서 다른 생성자를 호출할 때에는 반드시 첫 줄에서만 가능
    this.variable : 인스턴스 변수
    
    static은 this 사용 불가, 인스턴스가 생성되어 있을지 모름
    
    this : 인스턴스 자신을 가르키는 참조 변수, 인스턴스의 주소가 저장, 모든 인스턴스 메서드에 지역변수로 숨겨진채로 존재
    this(), this(매개변수) : 생성자, 같은 클래스의 다른 생성자를 호출할 때 사용
    
    this와 this()는 완전히 다름!

변수의 초기화   
    지역변수는 사용하기 전에 반드시 초기화
    멤버변수(클래스 변수와 인스턴스 변수), 배열의 초기화는 선택적(기본값이 들어감)
    boolean : false, 숫자 : 0, 참조형 : null

멤버변수(클래스 변수와 인스턴스 변수)의 초기화
    1. 클래스 변수 초기화 -> 인스턴스 변수 초기화
    2. 자동 초기화 -> 명시적 초기화 -> 초기화 블럭, 생성자

    명시적 초기화 : 선언과 동시에 초기화(int door=4;)
    초기화 블럭 : 클래스 초기화 블럭(static{}) / 인스턴스 초기화 블럭({})
    클래스 초기화 블럭은 한번만 실행되지만, 인스턴스 초기화 블럭은 인스턴스가 생성될 때마다 실행
    

상속
    기존의 클래스를 재사용하여 새로운 클래스를 작성, 코드를 공통적으로 관리할 수 있기에 유지보수 용이
    코드의 재사용성을 높이고 중복을 제거
    상속시 모든 멤버를 상속받음. 단, 생성자와 초기화 블럭은 상속되지 않음
    자바에서는 다중 상속이 불가능, 단일 상속만 가능 
        다중상속을 허용할 경우, 클래스 간 관계 매우 복잡해짐 + 다른 클래스로부터 상속받은 멤버간 이름이 같은 경우 구별 불가능
        불편한 점도 있지만 클래스 간 관계 명확, 코드 신뢰성 상승

포함관계
    포함 관계를 맺어주고 클래스를 재사용 가능
    한 클래스의 멤버 변수로 다른 클래스의 참조 변수를 선언

<cf>
    상속 : ~은 ~이다.(어느 종인지 그런 느낌인 듯)
    포함 : ~은 ~을 가지고 있다.

Object Class
    모든 클래스 상속계층도의 최상위에 있는 조상 클래스
    다른 클래스로부터 상속받지 않는 모든 클래스들은 자동적으로 Object 클래스로부터 상속받음
        SmartTv -> Tv -> Object
    
    Java의 모든 클래스는 Object의 메소드, 멤버를 사용할 수 있음(toString(), equals(),...)
    
오버라이딩(Overriding)
    조상으로부터 상속받은 메소드의 내용을 변경, 자손 클래스에 맞게 변경하는 것    
    새로운 메소드를 만드는 것 보다, overriding하면 조상 메소드에서도 사용하던 방식 그대로 사용
    
    1. 메소드의 내용만을 새로 작성하는 것, 메소드의 선언부(이름, 매개변수, 반환타입)는 조상의 것과 동일해야
    2. 접근 제어자는 조상 클래스의 메소드보다 좁은 범위로 변경할 수 없다.
    ex) 조상 : protected, 자손 : protected or public
    3. 조상 클래스의 메소드보다 많은 수의 예외를 선언할 수 없다.

super
    자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용하는 변수
    super() : 조상의 생성자
    클래스 자신에 선언된 변수는 자신의 생성자가 초기화를 책임지도록 작성하는 것이 바람직
        부모에 선언된 변수는 부모의 생성자로 초기화 되도록 하기
    
package(패키지)
    패키지,클래스의 묶음(클래스 또는 인터페이스를 포함), 서로 관련된 클래스들 끼리 그룹 단위로 묶음
    패키지도 다른 패키지를 포함할 수 있음
    클래스가 물리적으로 하나의 클래스 파일(.class) 이듯이, 패키지는 물리적으로 하나의 디렉토리
    
    패키지의 선언
        클래스나 인터페이스의 소스파일(.java)의 맨 위에 package 패캐지명;
        하나의 소스파일에 단 한번만 선언
        대소문자 모두 가능하나, 소문자로 하는 것이 원칙
        모든 클래스는 반드시 하나의 패키지에 선언되어야 함, 선언하지 않는 것들도 모두 자바에서 기본적으로 제공하는 이름없는 패키지(unnamed package)에 속해있음
        
    클래스패스(classpath)
        A클래스가 com.A.B 패키지에 포함되어 있다면, 클래스 파일인 A.class는 com/A/B 폴더 안에 있어야 함
        패키지의 루트 디렉토리를 클래스패스에 포함시켜야 함
        환경변수에 CLASSPATH, 변수값에 루트 디렉토리를 적어야 함(구분자 : ;)

    import
        컴파일러에게 소스파일에 사용된 클래스의 패키지에 대한 정보를 제공
        모든 소스파일에서 import문은 package문 다음에, 클래스 선언문 이전에 위치해야 함
        import 패키지명.클래스명;
        import 패키지명.*;
            두 선언문 간의 실행 시 성능상의 차이는 없음
            해당 패키지에서 일치하는 클래스 이름을 찾는 정도만 함
        
        static import
            static 멤버를 호출할 때 클래스 이름을 생략할 수 있음
            특정 클래스의 static 멤버를 자주 사용할 때 편리

제어자(modifier)
    접근 제어자 : public, protected, (default), private
    그 외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
    
    하나의 대상에 대해 여러 제어자를 조합해서 사용 가능, 하지만 접근 제어자는 한가지만 사용 가능
    
    static
        클래스에 관계된 것, 인스턴스를 생성하지 않고도 사용 가능
        인스턴스 멤버를 사용하지 않는 것이 제일 큰 특징, 사용하지 않는다면 static으로 지정하는 것이 좋음

        static 멤버변수
            모든 인스턴스에 공통적으로 사용되는 클래스 변수
            인스턴스를 생성하지 않고도 사용 가능
            클래스가 메모리에 로드될 때 생성
        
        static 메소드
            인스턴스를 생성하지 않고도 호출이 가능한 static 메소드
            static 메소드 내에서는 인스턴스 멤버들을 직접 사용할 수 없음

    final : 마지막, 변경될 수 없는
        final 클래스
            변경할 수 없는, 확장될 수 없는 클래스
            다른 클래스의 조상이 될 수 없음
        
        final 메소드
            변경될 수 없는 메소드, final로 지정된 메소드는 오버라이딩 될 수 없음

        final 멤버변수 지역변수
            값을 변경할 수 없는 상수

    abstract : 추상의, 미완성의
        abstract 클래스
            클래스 내에 추상 메소드가 선언되어 있음을 의미
            미완성 설계도이므로, 인스턴스 생성 불가

        abstract 메소드
            선언부만 작성하고, 구현부는 작성하지 않는 추상 메소드임을 알림
        

접근제어자
    private : 같은 클래스 내에서만 접근 가능
    default : 같은 패키지 내에서
    protected : 같은 패키지 내에서, 다른 패키지의 자손클래스(패키지에 관계 없이 상속관계에 있는 자손클래스에서 접근할 수 있도록 하는 것이 제한 목적)에서 접근 가능
    public : 접근 제한 전혀 없음

    접근 제어자 지정되어 있지 않다면 default로 설정됨

캡슐화(encapsulation)
    클래스의 내부에 선언된 데이터를 보호하기 위해서 사용
    유효한 값을 유지하고, 외부에서 함부로 변경하지 못하도록 하기 위해 외부에서의 접근 제한, 복잡성 줄임
    클래스 내에서만 사용되는, 내부 작업을 위해 임시로 사용되는 멤버 변수나 부분작업을 처리하기 위한 메소드 등의 멤버를 클래스 내부에 숨김

    getter,setter
        setter에서 유효한 값에 대한 조건을 검사 후, 조건에 맞는 값일때만 값을 변경
        getter는 값을 반환

다형성(polymorphism)
    한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함
    조상클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조

    SmartTv s = new SmartTv(); //일반적
    Tv t = new SmartTv(); //타입 불일치, 조상 타입의 참조변수로 자손 인스턴스 참조
    
    t는 SmartTv 인스턴스 중에서 Tv 클래스의 멤버들(상속받은 멤버 포함)만 사용할 수 있음
    둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 갯수가 달라짐

    자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다
        실제 인스턴스보다 참조변수가 사용할 수 있는 멤버 개수가 더 많기 때문

    여러 종류의 객체를 하나의 배열로 다룰 수도 있게 됨

    
참조변수의 형변환
    서로 상속관계에 있는 클래스 사이에서만 형변환 가능, 조상에서 자손으로, 자손에서 조상으로, Object로 등등
    기본형의 형변환과 달리 참조형의 형변환은 변수에 저장된 값(주소값)이 변환되는 것이 아님

    조상타입으로의 형변환은 생략 가능 : 다룰 수 있는 멤버의 개수가 줄으므로 항상 안전

    ex)     Car
          /     \
    FireEngine  Ambulance

    FireEngine f = new FireEngine();
    Car c = f // Car c = (Car) f : 생략 가능
    f = (FireEngine) c;

    리모컨(참조변수)를 다른 종류의 것으로 바꾼는 것뿐
        사용할 수 있는 멤버 개수 조절

    instanceof
        어떤 타입에 대한 instanceof 연산의 결과가 true라는 것은 검사한 타입으로의 형변환이 가능하다는 것
        

Vector
    동적으로 크기가 관리되는 객체 배열

추상 클래스 : 미완성 설계도
    미완성 메소드를 포함하고 있다는 의미
    인스턴스 생성 불가
    상속을 통해서 자손클래스에 의해서만 완성될 수 있음
    
    ex) TV를 만든다 하더라도, 기능의 차이에 따라 여러 종류의 모델이 있지만 대부분의 기능은 비슷, 이런 경우에 추상 클래스를 생성

    추상 클래스롭터 상속받는 자손 클래스는 오버라이딩을 통해 조상인 추상클래스의 추상메소드를 모두 구현해야 함
    추상 메소드 중 하나라도 구현하지 않는다면, 자손 클래스 역시 추상클래스로 지정해야 함

    상속이 자손 클래스를 만드는 데 조상 클래스를 사용하는 것이라면, 이와 반대로 추상화는 기존의 클래스의 공통 부분을 뽑아내서 조상 클래스를 만드는 것
    상속 계층도를 따라 내려갈수록 클래스는 점점 기능이 추가되어 구체화, 올라갈수록 추상화(DB super type과 유사한 듯)

인터페이스(Interface) : 기본 설계도
    일종의 추상 클래스, 추상화 정도가 높아서 일반 메소드 또는 멤버 변수를 구성원으로 가질 수 없음
    오직 추상 메소드와 상수만 멤버로 가질 수 있음

    접근 제어자로 public 또는 default만 사용 가능
    모든 멤버 변수는 public static final, 생략 가능
    모든 메소드는 public abstract, 생략 가능(단, static 메소드와 default 메소드는 예외)

    상속 가능, 다중 상속 가능
    
    클래스가 인터페이스를 상속받아서 추상 메소드를 구현해야 함, 클래스의 상속과 같지만 "implements" keyword 사용
    상속과 구현을 동시에도 가능

    인터페이스를 이용한 다형성
        해당 인터페이스 타입의 참조 변수로 이를 구현한 클래스의 인스턴스 참조 가능, 인터페이스 타입으로의 형변환도 가능
        인터페이스는 메소드의 매개변수 타입으로도 사용 가능
            해당 인터페이스를 구현한 클래스의 인스턴스를 매개변수로 제공해야 한다는 의미
        메소드의 리턴타입으로 인터페이스를 지정 가능
            메소드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는 의미

    장점
        개발시간 단축
            메소드를 호출하는 쪽에서는 메소드의 선언부와 역할만 알면 됨, 개발 동시 진행 가능
        표준화 가능
            일관화, 정형화
        서로 관계없는 클래스들에게 관계를 맺을 수 있음
            서로 상속관계에 있지도 않고, 같은 조상클래스를 가지고 있지 않은 서로 어떠한 관계도 없는 클래스들에게 하나의 인터페이스를 공통적으로 구현하도록 강제
        독립적 프로그래밍 가능
            클래스와 클래스 간의 직접적인 관계를 인터페이스를 이용해 간접적 관계로 변경
            한 클래스의 변경이 관련된 다른 클래스에 영향을 미치지 않는 독립적 프로그래밍 가능
            
디폴트 메소드(default method)
    인터페이스에 추상 메소드만 선언할 수 있었는데, 디폴트, 스태틱 메소드도 추가할 수 있게 됨
    인터페이스에 추상 메소드를 추가한다는 것은, 기존의 이 인터페이스를 구현한 모든 클래스에서 새로 추가된 메소드를 구현해야 함
    인터페이스가 변경되지 않으면 제일 좋겠지만, 아무리 설계를 잘해도 언젠가 변경은 발생하기 때문에 탄생
    
    디폴트 메소드는 추상 메소드의 기본적인 구현을 제공, 추상 메소드가 아니기 때문에 해당 인터페이스를 구현한 클래스를 변경하지 않아도 됨
    추상 메소드와 달리 일반 메소드처럼 몸통{}이 있어야 함, 접근제어자는 public

    새로 추가된 디폴트 메소드가 기존의 메소드와 이름이 중복되어 충돌 가능성 있음
    필요한 쪽의 메소드와 같은 내용으로 오버라이딩
    
    디폴트 메소드는 인터페이스에서 구현되는 함수라고 생각하면 될 듯,
    인터페이스를 implements만 해도 그 메소드를 호출할 수 있음

내부 클래스
    클래스 내에 선언된 클래스, 두 클래스가 서로 긴밀한 관계인 경우 사용
    내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근 가능, 캡슐화
    내부 클래스는 자신을 포함하고 있는 외부 클래스를 제외하고는 다른 클래스에서 잘 사용되지 않는 것

    내부 클래스는 마치 변수를 선언하는 것과 같은 위치에 선언할 수 있음
    abstract, final 같은 제어자 뿐만 아니라 멤버변수들처럼 private, protected의 접근제어자도 사용 가능

    인스턴스 클래스
        외부 클래스의 멤버변수 선언 위치에 선언, 외부 클래스의 인스턴스 멤버처럼 다루어짐

    스태틱 클래스
        외부 클래스의 멤버변수 선언 위치에 선언, 외부 클래스의 스태틱 멤버처럼 다루어짐
        주로 외부 클래스의 static 멤버, static 메소드에서 사용될 목적으로 선언

    지역 클래스
        외부 클래스의 메소드나 초기화 블럭 안에 선언, 선언된 영역 내부에서만 사용

    익명 클래스
        클래스의 선언과 객체의 생성을 동시에 하는 일회용 클래스
    
    내부 클래스 중에서 스태틱 클래스만 스태틱 멤버를 가질 수 있음, final static(상수)은 사용 가능

    인스턴스 클래스는 외부 클래스의 인스턴스 멤버를 객체 생성 없이 바로 사용 가능, 스태틱 클래스는 외부 클래스의 인스턴스 멤버를 객체생성 없이 사용 불가
    인스턴스 클래스는 스태틱 클래스의 멤버들을 객체생성 없이 사용할 수 있지만 스태틱 클래스에서는 인스턴스 클래스의 멤버들을 객체생성 없이 사용 불가

    외부 클래스가 아닌 다른 클래스에서 내부 클래스를 생성하고 내부 클래스의 멤버에 접근할 수 있긴 하지만, 그런 경우 내부 클래스로 선언하면 안되는 경우

    내부 클래스와 외부 클래스에 선언된 변수의 이름이 같을 때, 변수 앞에 this(내부)또는 외부 클래스명.this(외부)를 붙여서 서로 구별 가능

    지역 클래스는 외부 클래스의 인스턴스 멤버와 static 멤버를 모두 사용할 수 있으며 지역 클래스가 포함된 메소드에 정의된 지역변수도 사용 가능
    단, final이 붙은 지역변수만 접근 가능, 그 이유는 메소드가 수행을 마쳐서 지역변수가 소멸된 시점에도, 지역 클래스의 인스턴스가
    소멸된 지역변수를 참조하려는 경우가 발생할 수 있기 떄문